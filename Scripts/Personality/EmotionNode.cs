// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;


namespace ViAgents.Personality
{
	/// <summary>
	/// A node containing to contrasting emotions (a positive-negative pair)
	/// </summary>
	public class EmotionNode
	{
		private EmotionType positiveKey; //The positive emotion represented by this node
		private EmotionType negativeKey; //The negative emotion represented by this node

		private Dictionary<EmotionType, double[]> emotionTable = new Dictionary<EmotionType, double[]>(); //A dictionary storing the current/previous value of the emotions in this node

		private List<EmotionNode> parents = new List<EmotionNode>(); //The parent nodes of this node
		private List<EmotionNode> children = new List<EmotionNode>(); //The child nodes of this node
		
		public const double MAX_EMOTIONAL_INTENSITY = 1;
		public const double MIN_EMOTIONAL_INTENSITY = 0;
		
		public EmotionNode(EmotionType positiveEmotion, double positiveEmotionValue, 
		                   EmotionType negativeEmotion, double negativeEmotionValue)
		{
			positiveKey = positiveEmotion;
			negativeKey = negativeEmotion;
			emotionTable.Add(positiveKey, new double[2] {positiveEmotionValue, positiveEmotionValue});
			emotionTable.Add(negativeKey, new double[2] {negativeEmotionValue, negativeEmotionValue});
		}
		
		#region "Properties"
		
		public double PositiveEmotionValue
		{
			get { return emotionTable[positiveKey][0]; }
		}
		
		public double NegativeEmotionValue
		{
			get { return emotionTable[negativeKey][0]; }
		}
		
		public EmotionType NegativeEmotion
		{
			get { return negativeKey; }
		}
		
		public EmotionType PositiveEmotion
		{
			get { return positiveKey; }
		}
		
		public double EmotionValue(EmotionType et)
		{
			if (this.Represents(et))
				return emotionTable[et][0];
			else
				return 0;
		}
		
		public double EmotionValue(EmotionType et, int index)
		{
			if (this.Represents(et) && index <= 1)
				return emotionTable[et][index];
			else
				return 0;
		}
		
		public List<EmotionNode> Children
		{
			get { return children; }
		}
		
		#endregion
		
		/// <summary>
		/// Whether or not this node represents a certain emotion
		/// </summary>
		/// <param name="et">The emotion to be checked</param>
		/// <returns>True if this node represents it, false otherwise</returns>
		public Boolean Represents(EmotionType et)
		{
			return (et == positiveKey || et == negativeKey);
		}
		
		/// <summary>
		/// Add a child to this node
		/// </summary>
		/// <param name="node">The child node</param>
		public void Add(EmotionNode node)
		{
			children.Add(node);
			node.parents.Add(this);
		}
		
		#region EmotionValueManipulators
		
		/// <summary>
		/// Save the current values of the tree as the previous values
		/// </summary>
		public void backupState()
		{
			Console.WriteLine(String.Format("Backing up {0}/{1}", positiveKey.ToString(), negativeKey.ToString()));
			
			emotionTable[positiveKey][1] = emotionTable[positiveKey][0];
			emotionTable[negativeKey][1] = emotionTable[negativeKey][0];
		}
		
		/// <summary>
		/// Add to the existing emotional intensity of an existing emotion in the node
		/// </summary>
		/// <param name="et">The emotion to be added to</param>
		/// <param name="value">The intensity to be added</param>
		public void addToEmotion(EmotionType et, double value)
		{
			if (et == positiveKey)
				addToPositiveEmotion(value);
			else if (et == negativeKey)
				addToNegativeEmotion(value);
		}
		
		/// <summary>
		/// Used to make sure values don't go below zero
		/// </summary>
		private void rebound()
		{
			if (emotionTable[positiveKey][0] < 0)
				emotionTable[positiveKey][0] = 0;
			
			if (emotionTable[negativeKey][0] < 0)
				emotionTable[negativeKey][0] = 0;
		}
		
		/// <summary>
		/// Add to the intensity of an existing positive emotion, and counter-balance against
		/// the negative emotions of this node and the children
		/// </summary>
		/// <param name="value">The intensity to be added</param>
		public void addToPositiveEmotion(double value)
		{
			emotionTable[positiveKey][0] += value;
			emotionTable[negativeKey][0] -= value;
			
			// According to Bartneck (Integrating the OCC Model of Emotions in Emobodied Characters)
			// we need a way for emotions to interact with each other, and he suggests one way is to
			// counter effect positive and negative characters (p.3). In our implementation, we use
			// Steunebrink et al.'s inheritance structure to counter all the opposite emotions of
			// child emotional nodes (ie. increasing a positive emotion of a node decreases the 
			// negative emotions of all related child nodes).
			foreach (EmotionNode child in children)
			{
				child.addToNegativeEmotionFromParent(-1 * value);
			}
			
			rebound();
		}
		
		public void addToPositiveEmotionFromParent(double value)
		{
			emotionTable[positiveKey][0] += value;
			
			foreach (EmotionNode child in children)
			{
				child.addToPositiveEmotionFromParent(value);
			}
			
			rebound();
		}
		
		/// <summary>
		/// Add to the intensity of an existing negative emotion, and counter-balance against
		/// the positive emotions of this node and the children
		/// </summary>
		/// <param name="value">The intensity to be added</param>
		public void addToNegativeEmotion(double value)
		{
			emotionTable[negativeKey][0] += value;
			emotionTable[positiveKey][0] -= value;
			
			// According to Bartneck (Integrating the OCC Model of Emotions in Emobodied Characters)
			// we need a way for emotions to interact with each other, and he suggests one way is to
			// counter effect positive and negative characters (p.3). In our implementation, we use
			// Steunebrink et al.'s inheritance structure to counter all the opposite emotions of
			// child emotional nodes (ie. increasing a negative emotion of a node decreases the 
			// positive emotions of all related child nodes).
			foreach (EmotionNode child in children)
			{
				child.addToPositiveEmotionFromParent(-1 * value);
			}
			
			rebound();
		}
		
		public void addToNegativeEmotionFromParent(double value)
		{
			emotionTable[negativeKey][0] += (value);
			
			foreach (EmotionNode child in children)
			{
				child.addToNegativeEmotionFromParent(value);
			}
			
			rebound();
		}
		
		#endregion
	}
}

